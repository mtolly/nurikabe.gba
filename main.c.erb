#include <string.h>
#include <tonc.h>

#define WHITE 0
#define BLACK 1
#define DOT 2
#define OUTSIDE 3
#define BOTTOM_EDGE 4
#define RIGHT_EDGE 5
#define BOTTOM_RIGHT_CORNER 6
#define NUMBER(n) ((n) + 6)

#define CURSOR 32

int main() {

  <%
  puzzle = %w{
    2-4-2--2--
    ----------
    -----2----
    3-------3-
    ---2--3--3
    ----------
    3-----1---
    ---3------
    2-----3--2
    ---2------
  }
  %>

#define NUR_ROWS <%= puzzle.length %>
#define NUR_COLS <%= puzzle[0].length %>

  int puzzle[NUR_ROWS][NUR_COLS];
  <%=
  puzzle.each_with_index.map do |row, r|
    row.split('').each_with_index.map do |square, c|
      "puzzle[#{r}][#{c}] = #{square == '-' ? 'WHITE' : 'NUMBER(' + square + ')'};"
    end.join("\n")
  end.join("\n")
  %>

  int cursor_r = 0;
  int cursor_c = 0;

  <% require File.expand_path(File.dirname(__FILE__) + '/tiles.rb') %>

  // Load palette
  <%= load_pal_bg() %>

  // Load tiles into CBB 0
  <%= load_tile 0, 'WHITE', $white_tile %>
  <%= load_tile 0, 'BLACK', $black_tile %>
  <%= load_tile 0, 'DOT', $dot_tile %>
  <% (1..19).each do |i| %>
    <%= load_tile 0, "NUMBER(#{i})", $num_tiles[i] %>
  <% end %>

  <%= load_tile 0, 'WHITE + CURSOR', layer($white_tile, $cursor) %>
  <%= load_tile 0, 'BLACK + CURSOR', layer($black_tile, $cursor) %>
  <%= load_tile 0, 'DOT + CURSOR', layer($dot_tile, $cursor) %>
  <% (1..19).each do |i| %>
    <%= load_tile 0, "NUMBER(#{i}) + CURSOR", layer($num_tiles[i], $cursor) %>
  <% end %>

  <%= load_tile 0, 'OUTSIDE', $outside %>
  <%= load_tile 0, 'BOTTOM_EDGE', $bottom_edge %>
  <%= load_tile 0, 'RIGHT_EDGE', $right_edge %>
  <%= load_tile 0, 'BOTTOM_RIGHT_CORNER', $bottom_right_corner %>

  // Load map into SBB 30
  for (int i = 0; i < 32 * 32; i++) se_mem[30][i] = OUTSIDE;
  for (int c = 0; c < NUR_COLS; c++) se_mem[30][NUR_ROWS * 32 + c] = BOTTOM_EDGE;
  for (int r = 0; r < NUR_ROWS; r++) se_mem[30][r * 32 + NUR_COLS] = RIGHT_EDGE;
  se_mem[30][NUR_ROWS * 32 + NUR_COLS] = BOTTOM_RIGHT_CORNER;

  for (int r = 0; r < NUR_ROWS; r++) {
    for (int c = 0; c < NUR_COLS; c++) {
      se_mem[30][r * 32 + c] = puzzle[r][c];
    }
  }
  se_mem[30][cursor_r * 32 + cursor_c] += CURSOR;

  // set up BG0 for a 4bpp 64x32t map, using charblock 0 and screenblock 30
  REG_BG0CNT = BG_CBB(0) | BG_SBB(30) | BG_4BPP | BG_REG_64x32;
  REG_DISPCNT = DCNT_MODE0 | DCNT_BG0;

  irq_init(NULL);
  irq_add(II_VBLANK, NULL);

  int key_repeat = 0;
  bool clearing = false;
  while (1) {
    VBlankIntrWait();
    key_poll();
    se_mem[30][cursor_r * 32 + cursor_c] -= CURSOR; // remove the cursor
    if (key_hit(1 << KI_LEFT | 1 << KI_RIGHT | 1 << KI_UP | 1 << KI_DOWN)) {
      key_repeat = 0; // reset the key repeat timer
    }
#define START_REPEAT 20
#define REPEAT_SPEED 2
    if (key_is_down(1 << KI_LEFT | 1 << KI_RIGHT | 1 << KI_UP | 1 << KI_DOWN)) {
      if (key_repeat < START_REPEAT) key_repeat++;
      else key_repeat = START_REPEAT - REPEAT_SPEED;
    }
    bool virtual_left  = key_hit(1 << KI_LEFT ) || (key_is_down(1 << KI_LEFT ) && key_repeat == START_REPEAT);
    bool virtual_right = key_hit(1 << KI_RIGHT) || (key_is_down(1 << KI_RIGHT) && key_repeat == START_REPEAT);
    bool virtual_up    = key_hit(1 << KI_UP   ) || (key_is_down(1 << KI_UP   ) && key_repeat == START_REPEAT);
    bool virtual_down  = key_hit(1 << KI_DOWN ) || (key_is_down(1 << KI_DOWN ) && key_repeat == START_REPEAT);
    bool moved_cursor = false;
    if (virtual_left  && cursor_c > 0           ) { cursor_c--; moved_cursor = true; }
    if (virtual_right && cursor_c < NUR_COLS - 1) { cursor_c++; moved_cursor = true; }
    if (virtual_up    && cursor_r > 0           ) { cursor_r--; moved_cursor = true; }
    if (virtual_down  && cursor_r < NUR_ROWS - 1) { cursor_r++; moved_cursor = true; }

    if (key_hit(1 << KI_A)) {
      switch (puzzle[cursor_r][cursor_c]) {
        case WHITE:
        case BLACK:
          puzzle[cursor_r][cursor_c] = se_mem[30][cursor_r * 32 + cursor_c] = DOT;
          clearing = false;
          break;
        case DOT:
          puzzle[cursor_r][cursor_c] = se_mem[30][cursor_r * 32 + cursor_c] = WHITE;
          clearing = true;
          break;
        default:
          clearing = false;
          break;
      }
    }
    else if (key_is_down(1 << KI_A) && moved_cursor) {
      switch (puzzle[cursor_r][cursor_c]) {
        case WHITE:
        case BLACK:
        case DOT:
          if (clearing) {
            puzzle[cursor_r][cursor_c] = se_mem[30][cursor_r * 32 + cursor_c] = WHITE;
          }
          else {
            puzzle[cursor_r][cursor_c] = se_mem[30][cursor_r * 32 + cursor_c] = DOT;
          }
          break;
      }
    }

    if (key_hit(1 << KI_B)) {
      switch (puzzle[cursor_r][cursor_c]) {
        case WHITE:
        case DOT:
          puzzle[cursor_r][cursor_c] = se_mem[30][cursor_r * 32 + cursor_c] = BLACK;
          clearing = false;
          break;
        case BLACK:
          puzzle[cursor_r][cursor_c] = se_mem[30][cursor_r * 32 + cursor_c] = WHITE;
          clearing = true;
          break;
        default:
          clearing = false;
          break;
      }
    }
    else if (key_is_down(1 << KI_B) && moved_cursor) {
      switch (puzzle[cursor_r][cursor_c]) {
        case WHITE:
        case BLACK:
        case DOT:
          if (clearing) {
            puzzle[cursor_r][cursor_c] = se_mem[30][cursor_r * 32 + cursor_c] = WHITE;
          }
          else {
            puzzle[cursor_r][cursor_c] = se_mem[30][cursor_r * 32 + cursor_c] = BLACK;
          }
          break;
      }
    }

    se_mem[30][cursor_r * 32 + cursor_c] += CURSOR; // readd the cursor
  }
}
