#include <string.h>
#include <tonc.h>

int main() {

#define NUR_ROWS 10
#define NUR_COLS 13

  int puzzle[NUR_ROWS][NUR_COLS];
  //  0: blank
  // -1: black
  // -2: dot
  // positive: numbered
  for (int r = 0; r < NUR_ROWS; r++) {
    for (int c = 0; c < NUR_COLS; c++) {
      puzzle[r][c] = 0;
    }
  }
  puzzle[4][3] = -1;

  int cursor_r = 0;
  int cursor_c = 0;

  <% require File.expand_path(File.dirname(__FILE__) + '/tiles.rb') %>

  // Load palette
  <%= load_pal_bg() %>

  // Load tiles into CBB 0
  <%
  def load2(tile_index, tile)
    load_tile(0, tile_index, tile) + load_tile(0, 32 + tile_index, layer(tile, $cursor))
  end
  %>
  <%= load2 0, $white_tile %>
  <% (1..19).each do |i| %>
    <%= load2 i, $num_tiles[i] %>
  <% end %>
  <%= load2 26, $black_tile %>
  <%= load2 27, $dot_tile %>
  <%= load2 28, $outside %>
  <%= load2 29, $bottom_edge %>
  <%= load2 30, $right_edge %>
  <%= load2 31, $bottom_right_corner %>

  // Load map into SBB 30
  for (int i = 0; i < 32 * 32; i++) se_mem[30][i] = 28;
  for (int c = 0; c < NUR_COLS; c++) se_mem[30][NUR_ROWS * 32 + c] = 29;
  for (int r = 0; r < NUR_ROWS; r++) se_mem[30][r * 32 + NUR_COLS] = 30;
  se_mem[30][NUR_ROWS * 32 + NUR_COLS] = 31;

  for (int r = 0; r < NUR_ROWS; r++) {
    for (int c = 0; c < NUR_COLS; c++) {
      switch (puzzle[r][c]) {
        case 0:
          se_mem[30][r * 32 + c] = 0;
          break;
        case -1:
          se_mem[30][r * 32 + c] = 26;
          break;
        case -2:
          se_mem[30][r * 32 + c] = 27;
          break;
        default:
          se_mem[30][r * 32 + c] = puzzle[r][c];
          break;
      }
    }
  }
  se_mem[30][cursor_r * 32 + cursor_c] += 32;

  // set up BG0 for a 4bpp 64x32t map, using charblock 0 and screenblock 30
  REG_BG0CNT = BG_CBB(0) | BG_SBB(30) | BG_4BPP | BG_REG_64x32;
  REG_DISPCNT = DCNT_MODE0 | DCNT_BG0;

  irq_init(NULL);
  irq_add(II_VBLANK, NULL);

  while (1) {
    VBlankIntrWait();
    key_poll();
    se_mem[30][cursor_r * 32 + cursor_c] -= 32;
    if (key_hit(1 << KI_LEFT) && cursor_c > 0) cursor_c--;
    if (key_hit(1 << KI_RIGHT) && cursor_c < NUR_COLS - 1) cursor_c++;
    if (key_hit(1 << KI_UP) && cursor_r > 0) cursor_r--;
    if (key_hit(1 << KI_DOWN) && cursor_r < NUR_ROWS - 1) cursor_r++;
    se_mem[30][cursor_r * 32 + cursor_c] += 32;
  }
}
